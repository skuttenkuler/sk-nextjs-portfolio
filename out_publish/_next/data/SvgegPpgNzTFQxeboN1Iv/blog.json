{"pageProps":{"articles":{"status":"ok","feed":{"url":"https://medium.com/feed/@sam-kuttenk","title":"Stories by Samuel Kuttenkuler on Medium","link":"https://medium.com/@sam-kuttenk?source=rss-118b5533365c------2","author":"","description":"Stories by Samuel Kuttenkuler on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*bnZlaX9PGhtSq1xPUBMOlg.png"},"items":[{"title":"REST API","pubDate":"2020-02-04 00:20:06","link":"https://medium.com/@sam-kuttenk/rest-api-591cb9698ddc?source=rss-118b5533365c------2","guid":"https://medium.com/p/591cb9698ddc","author":"Samuel Kuttenkuler","thumbnail":"https://cdn-images-1.medium.com/proxy/1*3UaLDKs6bJRMtYoPDCIWBw.png","description":"\n<p><em>(RE)presentational (S)tate (T)ransfer</em></p>\n<p>What is <a href=\"https://restfulapi.net/\">REST</a>?</p>\n<ul>\n<li>REST is a resource-based software architectural style in which six constraints must be satisfied in order for an interface to be referred to as RESTful.</li>\n<li>REST is resource based not action based ( nouns vs verbs).</li>\n<li>SIX CONSTRAINTS: Uniform Interface, Stateless, Client — Server, Cacheable, Layered System, Code on Demand</li>\n</ul>\n<figure><img alt=\"Image result for rest api meme\" src=\"https://cdn-images-1.medium.com/proxy/1*3UaLDKs6bJRMtYoPDCIWBw.png\"></figure><p>In a RESTful API, we are thinking in nouns (resources) not in actions such as SOAP. Putting it simply, nouns and verbs or things and actions. These resources are identified by URI’s (a string that unambiguously identifies a particular resource). In REST you can have multiple URI’s referring to the same resource.</p>\n<p>Representations are how we as developers manipulate our resources and is part of the resource state. BUT WAIT? I thought that one of the constraints of a RESTFUL API was being stateless?? So in this particular architecture style client and server are separate but the session state is held in the transfer between client and server NOT THE CLIENT. The server contains no client state. Each request that is made contains enough context to process the message given, though the messages must be very self descriptive. The format of the data in the representations are typically in Javascript Object Notation(JSON) or Extensible Markup Language(XML).</p>\n<p>Representation Example:</p>\n<p>Resource:</p>\n<ul><li>musician(Thelonious Monk)</li></ul>\n<p>Service:</p>\n<ul><li>Artist Info (GET)</li></ul>\n<p>Representation to get back:</p>\n<ul>\n<li>Name, Albums, Age, etc</li>\n<li>All in JSON or XML</li>\n</ul>\n<h3><strong>THE SIX CONSTRAINTS OF REST</strong></h3>\n<blockquote><strong>1. Uniform Interface</strong></blockquote>\n<ul><li>This defines the interface between the client and server by simplifying and decoupling the architecture. Uniform Interface is fundamental to a RESTful design. The relationship between client and server is established with HTTP verbs, URI’s, and HTTP responses:</li></ul>\n<p>— HTTP =&gt; GET, PUT, POST, DELETE</p>\n<p>— URI’s =&gt; the resource name</p>\n<p>— HTTP =&gt;(status, body)</p>\n<figure><img alt=\"Image result for rest api cartoon\" src=\"https://cdn-images-1.medium.com/proxy/1*5xCTnv1iKyFSaF8iKU_ltw.png\"></figure><blockquote><strong>2. Stateless</strong></blockquote>\n<ul><li>The server contains none of the client state only session state is held.</li></ul>\n<blockquote><strong>3. Client / Server</strong></blockquote>\n<ul><li>When using REST one must assume a disconnected system, the client and server are not touching or connected, each are merely “shouting” at each other. Shouting a request, server listening for that request, taking that request, and shouting back a response that the client is listening for. The shouting and listening “connection” is <em>Uniform Interface.</em>\n</li></ul>\n<p><strong>4.</strong> <strong>Cacheable</strong></p>\n<ul><li>In the server, responses(representations) are cacheable. Caching is the ability to store copies of frequently accessed data in the client to server call and response interface. When a user sends a request with a resource representation, the request goes through a cache or multiple caches toward the server hosting the resource the user is listening for. If any of the caches along the request have a copy of the requested representation, it uses that copy to satisfy the request. This processes will reduce bandwidth, latency, and the overall load on servers.</li></ul>\n<blockquote>\n<strong>5.</strong> <strong>Layered System</strong>\n</blockquote>\n<ul><li>As mentioned in <strong>Client / Server</strong>, a developer must assume a disconnected system. In REST the software or hardware is the intermediary between client and server. Keeping this disconnected relationship is a great utility for scaling.</li></ul>\n<blockquote>\n<strong>6.</strong> <strong>Code on Demand</strong>\n</blockquote>\n<ul><li>The Code on Demand paradigm is the only constraint of the six that is optional. This constraint allows clients to improve flexibility by giving the server the control to decide how certain things will be done. The code(like Java applets or Javascript) lies inactive on a web server until a client requests a web page that holds a link to the code using the client’s web browser.</li></ul>\n<p><strong>RESTful API calls with Node.js, Express, and MongoDB</strong></p>\n<p>install <a href=\"https://expressjs.com/\">Express</a>, <a href=\"https://nodejs.org/en/\">Node</a>, and <a href=\"https://www.mongodb.com/cloud/atlas/lp/general/try?utm_source=google&amp;utm_campaign=gs_americas_united%20states_search_brand_atlas_desktop&amp;utm_term=mongodb&amp;utm_medium=cpc_paid_search&amp;utm_ad=e&amp;gclid=Cj0KCQiA4NTxBRDxARIsAHyp6gBRGWBwng7NZbnp9YIcYm417kbj9lmYRik1K5-QXShjD9ZaaXwIUPUaAmujEALw_wcB\">MongoDB</a></p>\n<ul><li>server.js</li></ul>\n<pre>//import packages<br>const express = require('express');<br>const mongojs = require('mongojs');</pre>\n<pre>//connection to the db<br>const databaseURL = \"vinyl\";<br>const collections = [\"records\"];<br>const db = mongojs(databaseURL, collections);</pre>\n<pre>//grant ability to create routes with express very easily<br>cost app = express();</pre>\n<pre>app.use(express.urlencoded({ extended: true }));<br>app.use(express.json());<br>app.use(express.static(\"public\"));</pre>\n<pre>/////////ROUTES/////////<br></pre>\n<pre>////////////////////////</pre>\n<pre><br>//listen for server<br>app.listen(3000, () =&gt; {<br>console.log(\"Server is listening on PORT: 3000\");<br>});</pre>\n<p>In the ROUTES section in server.js will be examples of :</p>\n<p>GET, PUT, POST, DELETE</p>\n<ul><li>GET</li></ul>\n<pre>//If I (user) want to see the Records i have listened to </pre>\n<pre>//using get http verb when \"newRecords\" is visited.<br>app.get(\"/newRecords\", (req, res) =&gt; {</pre>\n<pre>// GET any resource in records collection with a variable listened   // with a value of false.<br>db.records.find({ listened: true }, (error, data) =&gt; {</pre>\n<pre>//if there is an error then log that error<br>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>} else {</pre>\n<pre>// server with send back the data the user is asking for in JSON <br>// format<br>res.json(data);</pre>\n<pre>}</pre>\n<pre>});</pre>\n<pre>});</pre>\n<ul><li>POST</li></ul>\n<pre>// HTTP POST verb for when \"add\" is visited<br>app.post(\"/add\", ({ newRecord }, res) =&gt; {</pre>\n<pre>//new record Object that will add(POST) the new object to our db<br>const record = newRecord;</pre>\n<pre>//set boolean for object<br>record.listened = false;</pre>\n<pre>//mongojs save method to save to collection<br>db.records.save(record, (error, added) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>} else {</pre>\n<pre>// server responds with the updated collection including our new<br>// record<br>res.send(added);</pre>\n<pre>}</pre>\n<pre>});</pre>\n<pre>});</pre>\n<ul><li>PUT</li></ul>\n<pre>//HTTP PUT verb for when \"marklistened/:id\" is visited<br>app.put(\"/marklistened/:id\", ({ params }, res) =&gt; {</pre>\n<pre>//mongo update method on records collection<br>db.records.update(</pre>\n<pre>// match the id of the record we want updated<br>{ _id: mongojs.ObjectId(params.id) },</pre>\n<pre>//once we find the record we want to update, set the new value<br>{ $set: { listened: true}</pre>\n<pre>},</pre>\n<pre>(error, edited) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>//if error send an error<br>res.send(error);</pre>\n<pre>} else {<br>// server response to client call</pre>\n<pre>res.send(edited);</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>);</pre>\n<pre>});</pre>\n<ul><li>DELETE</li></ul>\n<pre>HTTP DELETE verb for when \"delete/:id\" is visited<br>app.delete(\"/delete/:id\", ({ params }, res) =&gt; {</pre>\n<pre>//Mongojs method remove on the record we want deleted<br>db.records.remove(</pre>\n<pre>// once we match the record ID we want to delete, remove it from the<br>// collection<br>{ _id: mongojs.ObjectId(params.id) },</pre>\n<pre>(error, deleted) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>res.send(error);</pre>\n<pre>} else {</pre>\n<pre>console.log(deleted);</pre>\n<pre>// server response to client call<br>res.send(deleted);</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>);</pre>\n<pre>});</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=591cb9698ddc\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p><em>(RE)presentational (S)tate (T)ransfer</em></p>\n<p>What is <a href=\"https://restfulapi.net/\">REST</a>?</p>\n<ul>\n<li>REST is a resource-based software architectural style in which six constraints must be satisfied in order for an interface to be referred to as RESTful.</li>\n<li>REST is resource based not action based ( nouns vs verbs).</li>\n<li>SIX CONSTRAINTS: Uniform Interface, Stateless, Client — Server, Cacheable, Layered System, Code on Demand</li>\n</ul>\n<figure><img alt=\"Image result for rest api meme\" src=\"https://cdn-images-1.medium.com/proxy/1*3UaLDKs6bJRMtYoPDCIWBw.png\"></figure><p>In a RESTful API, we are thinking in nouns (resources) not in actions such as SOAP. Putting it simply, nouns and verbs or things and actions. These resources are identified by URI’s (a string that unambiguously identifies a particular resource). In REST you can have multiple URI’s referring to the same resource.</p>\n<p>Representations are how we as developers manipulate our resources and is part of the resource state. BUT WAIT? I thought that one of the constraints of a RESTFUL API was being stateless?? So in this particular architecture style client and server are separate but the session state is held in the transfer between client and server NOT THE CLIENT. The server contains no client state. Each request that is made contains enough context to process the message given, though the messages must be very self descriptive. The format of the data in the representations are typically in Javascript Object Notation(JSON) or Extensible Markup Language(XML).</p>\n<p>Representation Example:</p>\n<p>Resource:</p>\n<ul><li>musician(Thelonious Monk)</li></ul>\n<p>Service:</p>\n<ul><li>Artist Info (GET)</li></ul>\n<p>Representation to get back:</p>\n<ul>\n<li>Name, Albums, Age, etc</li>\n<li>All in JSON or XML</li>\n</ul>\n<h3><strong>THE SIX CONSTRAINTS OF REST</strong></h3>\n<blockquote><strong>1. Uniform Interface</strong></blockquote>\n<ul><li>This defines the interface between the client and server by simplifying and decoupling the architecture. Uniform Interface is fundamental to a RESTful design. The relationship between client and server is established with HTTP verbs, URI’s, and HTTP responses:</li></ul>\n<p>— HTTP =&gt; GET, PUT, POST, DELETE</p>\n<p>— URI’s =&gt; the resource name</p>\n<p>— HTTP =&gt;(status, body)</p>\n<figure><img alt=\"Image result for rest api cartoon\" src=\"https://cdn-images-1.medium.com/proxy/1*5xCTnv1iKyFSaF8iKU_ltw.png\"></figure><blockquote><strong>2. Stateless</strong></blockquote>\n<ul><li>The server contains none of the client state only session state is held.</li></ul>\n<blockquote><strong>3. Client / Server</strong></blockquote>\n<ul><li>When using REST one must assume a disconnected system, the client and server are not touching or connected, each are merely “shouting” at each other. Shouting a request, server listening for that request, taking that request, and shouting back a response that the client is listening for. The shouting and listening “connection” is <em>Uniform Interface.</em>\n</li></ul>\n<p><strong>4.</strong> <strong>Cacheable</strong></p>\n<ul><li>In the server, responses(representations) are cacheable. Caching is the ability to store copies of frequently accessed data in the client to server call and response interface. When a user sends a request with a resource representation, the request goes through a cache or multiple caches toward the server hosting the resource the user is listening for. If any of the caches along the request have a copy of the requested representation, it uses that copy to satisfy the request. This processes will reduce bandwidth, latency, and the overall load on servers.</li></ul>\n<blockquote>\n<strong>5.</strong> <strong>Layered System</strong>\n</blockquote>\n<ul><li>As mentioned in <strong>Client / Server</strong>, a developer must assume a disconnected system. In REST the software or hardware is the intermediary between client and server. Keeping this disconnected relationship is a great utility for scaling.</li></ul>\n<blockquote>\n<strong>6.</strong> <strong>Code on Demand</strong>\n</blockquote>\n<ul><li>The Code on Demand paradigm is the only constraint of the six that is optional. This constraint allows clients to improve flexibility by giving the server the control to decide how certain things will be done. The code(like Java applets or Javascript) lies inactive on a web server until a client requests a web page that holds a link to the code using the client’s web browser.</li></ul>\n<p><strong>RESTful API calls with Node.js, Express, and MongoDB</strong></p>\n<p>install <a href=\"https://expressjs.com/\">Express</a>, <a href=\"https://nodejs.org/en/\">Node</a>, and <a href=\"https://www.mongodb.com/cloud/atlas/lp/general/try?utm_source=google&amp;utm_campaign=gs_americas_united%20states_search_brand_atlas_desktop&amp;utm_term=mongodb&amp;utm_medium=cpc_paid_search&amp;utm_ad=e&amp;gclid=Cj0KCQiA4NTxBRDxARIsAHyp6gBRGWBwng7NZbnp9YIcYm417kbj9lmYRik1K5-QXShjD9ZaaXwIUPUaAmujEALw_wcB\">MongoDB</a></p>\n<ul><li>server.js</li></ul>\n<pre>//import packages<br>const express = require('express');<br>const mongojs = require('mongojs');</pre>\n<pre>//connection to the db<br>const databaseURL = \"vinyl\";<br>const collections = [\"records\"];<br>const db = mongojs(databaseURL, collections);</pre>\n<pre>//grant ability to create routes with express very easily<br>cost app = express();</pre>\n<pre>app.use(express.urlencoded({ extended: true }));<br>app.use(express.json());<br>app.use(express.static(\"public\"));</pre>\n<pre>/////////ROUTES/////////<br></pre>\n<pre>////////////////////////</pre>\n<pre><br>//listen for server<br>app.listen(3000, () =&gt; {<br>console.log(\"Server is listening on PORT: 3000\");<br>});</pre>\n<p>In the ROUTES section in server.js will be examples of :</p>\n<p>GET, PUT, POST, DELETE</p>\n<ul><li>GET</li></ul>\n<pre>//If I (user) want to see the Records i have listened to </pre>\n<pre>//using get http verb when \"newRecords\" is visited.<br>app.get(\"/newRecords\", (req, res) =&gt; {</pre>\n<pre>// GET any resource in records collection with a variable listened   // with a value of false.<br>db.records.find({ listened: true }, (error, data) =&gt; {</pre>\n<pre>//if there is an error then log that error<br>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>} else {</pre>\n<pre>// server with send back the data the user is asking for in JSON <br>// format<br>res.json(data);</pre>\n<pre>}</pre>\n<pre>});</pre>\n<pre>});</pre>\n<ul><li>POST</li></ul>\n<pre>// HTTP POST verb for when \"add\" is visited<br>app.post(\"/add\", ({ newRecord }, res) =&gt; {</pre>\n<pre>//new record Object that will add(POST) the new object to our db<br>const record = newRecord;</pre>\n<pre>//set boolean for object<br>record.listened = false;</pre>\n<pre>//mongojs save method to save to collection<br>db.records.save(record, (error, added) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>} else {</pre>\n<pre>// server responds with the updated collection including our new<br>// record<br>res.send(added);</pre>\n<pre>}</pre>\n<pre>});</pre>\n<pre>});</pre>\n<ul><li>PUT</li></ul>\n<pre>//HTTP PUT verb for when \"marklistened/:id\" is visited<br>app.put(\"/marklistened/:id\", ({ params }, res) =&gt; {</pre>\n<pre>//mongo update method on records collection<br>db.records.update(</pre>\n<pre>// match the id of the record we want updated<br>{ _id: mongojs.ObjectId(params.id) },</pre>\n<pre>//once we find the record we want to update, set the new value<br>{ $set: { listened: true}</pre>\n<pre>},</pre>\n<pre>(error, edited) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>//if error send an error<br>res.send(error);</pre>\n<pre>} else {<br>// server response to client call</pre>\n<pre>res.send(edited);</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>);</pre>\n<pre>});</pre>\n<ul><li>DELETE</li></ul>\n<pre>HTTP DELETE verb for when \"delete/:id\" is visited<br>app.delete(\"/delete/:id\", ({ params }, res) =&gt; {</pre>\n<pre>//Mongojs method remove on the record we want deleted<br>db.records.remove(</pre>\n<pre>// once we match the record ID we want to delete, remove it from the<br>// collection<br>{ _id: mongojs.ObjectId(params.id) },</pre>\n<pre>(error, deleted) =&gt; {</pre>\n<pre>if (error) {</pre>\n<pre>console.log(error);</pre>\n<pre>res.send(error);</pre>\n<pre>} else {</pre>\n<pre>console.log(deleted);</pre>\n<pre>// server response to client call<br>res.send(deleted);</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>);</pre>\n<pre>});</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=591cb9698ddc\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["rest-api"]},{"title":"Authorization and User data with Firebase.","pubDate":"2019-12-22 22:36:56","link":"https://medium.com/@sam-kuttenk/authorization-and-user-data-with-firebase-f22f800d2eb8?source=rss-118b5533365c------2","guid":"https://medium.com/p/f22f800d2eb8","author":"Samuel Kuttenkuler","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*x8LjUUpPNMwrutD5mee2pw.png","description":"\n<h3>Firebase: Authorization and User data.</h3>\n<p>Firebase is a very user friendly Software Development platform that was acquired by Google in 2014. Setting up a user authorization form can be a little daunting but Firebase makes it very easy. The first step is to <a href=\"http://firebase.com/\">create a Firebase account</a> then create a new app, select the mediums that you will be using, in the case of this blog a “web app”. Once that is done Firebase will give you the keys to the car.</p>\n<p>Your web app’s own firebaseConfig object which stores your apiKey, authDomain(where you’re going to call and sen user input for sign up and login), your databaseURL, and some other goodies along with and initializer. This block of code needs to be copied and pasted at the bottom of your index.html file just under the &lt;body&gt; tag. I like to go ahead and point to what I will be using for example:</p>\n<p>const auth = firebase.auth(); (points to the authorization domain)</p>\n<p>const db = firebase.firestore(); (points to the Firestore database)</p>\n<p>Once I have my pointers I will start working out creating users for my auth().</p>\n<p>Below is a method out of the Firebase auth toolbox taking in an email and password from an html form, then once the method has taken in the values from the form it will fire a function with a resoponse(cred):</p>\n<p>auth.createUserWithEmailAndPassword(email, password).then(cred =&gt; {</p>\n<p>If there is more information to be saved I will take the userID from the cred(response) and call the db, make a collection(objects in firebase) with the name “users” point to the specific ID of the User, set the values, and push to the database.</p>\n<p>return db.collection(“users”).doc(userID).set({</p>\n<p>username:$(“#username”).val(),</p>\n<p>});</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*x8LjUUpPNMwrutD5mee2pw.png\"></figure><p>Once that is saved the User email and password will be in the Auth Domaine and the other user input will be saved with the same userID as our created user. If I wanted to get the data for displaying on the DOM I would call the db collection of “users”, point to the specific userID and you a .get method to fetch the data, once that is done it will fire a function that returns the data:</p>\n<p>db.collection(“users”).doc(user.uid).get().then(doc =&gt; {</p>\n<p>userData = doc.data();</p>\n<p>username = userData.name;</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f22f800d2eb8\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Firebase: Authorization and User data.</h3>\n<p>Firebase is a very user friendly Software Development platform that was acquired by Google in 2014. Setting up a user authorization form can be a little daunting but Firebase makes it very easy. The first step is to <a href=\"http://firebase.com/\">create a Firebase account</a> then create a new app, select the mediums that you will be using, in the case of this blog a “web app”. Once that is done Firebase will give you the keys to the car.</p>\n<p>Your web app’s own firebaseConfig object which stores your apiKey, authDomain(where you’re going to call and sen user input for sign up and login), your databaseURL, and some other goodies along with and initializer. This block of code needs to be copied and pasted at the bottom of your index.html file just under the &lt;body&gt; tag. I like to go ahead and point to what I will be using for example:</p>\n<p>const auth = firebase.auth(); (points to the authorization domain)</p>\n<p>const db = firebase.firestore(); (points to the Firestore database)</p>\n<p>Once I have my pointers I will start working out creating users for my auth().</p>\n<p>Below is a method out of the Firebase auth toolbox taking in an email and password from an html form, then once the method has taken in the values from the form it will fire a function with a resoponse(cred):</p>\n<p>auth.createUserWithEmailAndPassword(email, password).then(cred =&gt; {</p>\n<p>If there is more information to be saved I will take the userID from the cred(response) and call the db, make a collection(objects in firebase) with the name “users” point to the specific ID of the User, set the values, and push to the database.</p>\n<p>return db.collection(“users”).doc(userID).set({</p>\n<p>username:$(“#username”).val(),</p>\n<p>});</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*x8LjUUpPNMwrutD5mee2pw.png\"></figure><p>Once that is saved the User email and password will be in the Auth Domaine and the other user input will be saved with the same userID as our created user. If I wanted to get the data for displaying on the DOM I would call the db collection of “users”, point to the specific userID and you a .get method to fetch the data, once that is done it will fire a function that returns the data:</p>\n<p>db.collection(“users”).doc(user.uid).get().then(doc =&gt; {</p>\n<p>userData = doc.data();</p>\n<p>username = userData.name;</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f22f800d2eb8\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["firebase"]}]}},"__N_SSG":true}